Used to build interactive Web-Pages.
Browsers have a JS Engine: Chrome - V8 & FireFox - SpiderMonkey.
Node - Ryan Dahl Developed C++ program that embedded V8.
JS code can be run - browser, node.
ECMAScipt -> Specification, JS -> Prog Lang.

------------

Script tag in HTML at end of body tag is best practice, here's why
-> Browser loads HTML in up-down form so HTML should load b4 JS code.
-> JS code usually interacts with HTML elements which thus need to be readily rendered.

------------

HTML -> Content/Noun, JS -> Behaviour/Verb, CSS -> Looks/Adjective.

Variables are boxes in which we store stuff. JS variables were declared using var but since ES6 let is used. By default, variables are undefined once declared. They are assigned a type when value is stored in them. Variables shouldnt contain space/hyphen. Use camel notation. They're case-sensitive. Multiple vars can be defined on 1 line but it's good practice to declare 1 var per line.

Constants can be initialized using const whose values can't be changed once assigned.

--------------------------------------------------------
Data Types
Data Types specify the type of value that is stored in a variable. 
JS follows dynamic typing wherein there's no need to manually define datatype for a variable's value. It is determined automatically. This also infers that we can change the type of a variable dynamically when needed.
-> Primitive/Value:String, Boolean, Number, undefined, null, symbol(ES6), BigInt(ES2020).
-> Reference:object, array, function.

undefined is a value and a primitive data type-both. This means that a variable that's only been declared will have undefined as its value as well as its datatype.

Objects are the combination of 2 or more key-value pairs. They are dynamic which means that we can always add more values to it. Defined using {} braces & accessed using dot notation(for static selection of key) & bracket notation(for dynamic selection of key).

Array is a DS that stores a list of values following the index format. They can be accessed using their index. Arrays are objects as well with their own properties.

Functions are a block of statements that perform a meaningful task. They're reusable. They can be passed values and return a value as well using return.
Argument -> Value suplied to a function call.
Parameter -> Variable in function definition to whom argument is passed.

Note: typeof Null is object which is a bug in JS and isnt fixed for legacy reasons.

BigInt(ES2020): We can store 2^53 - 1 numbers safely in numbers datatype. Any number after that is unsafe to use due to inconsistent outputs. We can convert a number to BigINt type by suffixing it with n.

--------------

Declaring variables:
let, const & var can be used.
let-> reassign, mutate & declare empty variables.
const-> immutable.

--------------

Operators can be used on variables(operands) to form an operation/expression which then returns a value. This mechanism can be used to implement logic & develop Algorithms.
->Arithmetic: +, -, _, /, %, \*\*, ++, --
->Assignment: =, +=, -+, _=, /=, %=
->Comparison:
->Relational: >, >=, <, <=  
->Equality: ===, !==, ==
->Ternary: ?:

Note: + operator always converts numbers to string types in operations. All other operators do it vice versa.
Note: == & === both compare for equality. ==(lose equality) checks only for value equality whereas ===(strict equality) looks for data type as well as value equality. Lose equality(==) converts 2nd operand to 1st operand's datatype b4 comparing.

->Logical: &&, ||, !

Note: Logical Operators can be used with non Boolean values. Result of Logical op is not always true/false but depends on operands. Non boolean values are interpreted as Truthy/Falsy by JS Engine. Falsy: false, undefined, NaN, 0, null, ''(empty string). Anything that's not falsy is always truthy. Truthy value is returned from logical ops when compared with false.
In a chain/curcuit of consecutive ORs, JS returns the very first Truthy value that it finds therefore breaking the so-called circuit. ANDs work exactly opposite of this, meaining, in a chain of ANDs, it returns the first Falsy value it encounters. It revolves aroud the phenomenon that if in a chain of values, even a single one of them is Falsy, the entire expression output is False(in case of ORs its exactly opposite). Use case for AND short curcuiting-
1.Check whether a function exists, and if it does then call it, else simply ignore the expression.
Use case for OR short cicuiting-
2.Set default values if a variable doesn't store a value.
Note: If all values in chain are True JS will reach end of expr & return last value.

->Bitwise: &, |

--------------------------------------------------------
Control Structures
If else is conditional statement that checks for 1/more conditions given and executes different block of code as per condition. Switch case compares a variable with multiple values in each case and executes some stmnts when comparison is true. switch case is kinda outdated.

Loops repeat a code block until given condition is true. 
-> for loop initialises a variable called the iterator, checks condition, executes code if true, incerements/decrements iterator and checks again. 
-> while loops are used when we dont know exact how many repetitions are to be done or the number of repetitions is dynamically decided. It simply checks condition and executes code until condition becomes false. 
-> do...while loop executes code block once regardless of the condition & then checks condition.
-> for...in loop is used to iterate over objects and stores key in var.
-> for...of(ES6) is used to iterate over iterables and stores elements in var per iteration. It hides all details of iterator and increments. To get index at each iteration as well, we need to call the entries() method on the object. This will now return an array of the index and item at that index per iteration. for...in can be used for arrays but it stores index in var, not individual array elements.

--------------

'use strict'; 
It enables strict mode in JS. Forbids us from doing certain things that may result in errors/bugs. Create visible errors when it would have otherwise failed silently.

--------------------------------------------------------
Functions:
Functions are user-defined/predefined blocks of code that can be run with just 1 line. They are used to reuse a block of code. They are first defined and then can be run by invoking/calling/running the function using it's function name just like we use a variable name to reuse the value stored in it. Functions are passed variables called as parameters. These variables(arguments) are passed when calling the function and are used by function definition. The variables in function definiton that are passed values from a function call are called as parameters. They can be used only within the function block(that is their scope). Functions also return some data back to where it was called from. This is called as returning a value. Functions in JS are basically a type of object implying they are values which thus allow us to create & assign them to a variable as well.
Functions can be defined in 2 ways:
-> Function Declaration: Define the function anywhere but it can be called even before declaring.
-> Function Expression: Define a nameless function and store it into a variable that acts as the function name. Can't call before being declared.
-> Arrow Functions(ES6): Special type of Function Expressions. Uses => operator between parameter list and code block. No need to use function keyword.

Since ES6, we can specify default parameter values by specifying them in parameter list with equal to operator. To skip an in-between parameter and set it to it's default value, you can pass undefined(which is just as if we didn't pass it a value).

We don't pass by reference in JS. We just simply pass a reference into the function as a value for reference datatypes & primitive datatypes are simple passed by value.

--------------

Types of Functions:
1. First-Order Functions: Normal functions. All functions are values. (Feature of JS)
2. Higher-Order Functions: Functions that return a function/ are passed one as an argument. This is possible due to First-Order Functions existing in the first place. A function passed as an argument is called as callback func(it gets called back by Higher-Order func).
These 2 types are present to implement abstraction in JS. By hiding some details in first-order functions, we can think about our problems on a higher & more abstract level with higher-order functions.

--------------

Call, Apply & Bind methods:
These functions are used to explicitly set the this pointer when calling a function. This is useful when multiple objects want to use the same function and dynamically use their own property values using this pointer. However, in a simple function call, this points to undefined. These 3 methods belong to the functions since they themselves are also objects in JS. To explicitly specify JS engine that this should point to specific method, we use these methods:
1. function.call(object, ...arguments): Takes object for this followed by arguments.
2. function.apply(object, argumentArray): Takes arguments in an array.
3. function.bind(object, optionalParams): It does same but doesnt immediately call the function, rather returns one with this pointing to object passed. We can also specify arguments that would be permenantly bind when calling new returned function. This phenomenon is called partial application where we already partially set the argument values for anytime a function call happens. It's use case is in binding the this keyword to an object when passing the function to an event listener. This can't be done otherwise using the call/apply bcuz they call the function instantly.

Note: All objects trying to call the same function with this pointing to them should have same property names.

--------------

Immediately Invoked Function Expressions:
Used to invoke a function immediately after defining it and never using it again. This can be done by defining the function without a name, enclosing it in () thereby tricking JS into thinkinc its an expression and then following it by another () to call it there itself. These are like single use disposable functions needed just once.

--------------

Closures:
Any function always has access to variable environment of the execution context in which it was created(even after the execution context is removed from call stack). This VE is called closure. It is accessible exactly as it was when the function was created. Whenever a function tries to access a variable from a VE that no longer exists as an Excution Context in call stack, JS engine searches for this variable name in closure before looking in the scope chain of this function. Closures have higher priority over the scope chain as well. This variable environment that no longer exists is said to be closed over VE.

Closure gives a function access to variables of its parent function, even after the parent function has returned. The function keeps a reference to the outer scope which preserves the scope chain throughout time. It doesn't lose connection to variables that were present in the context where the function was created. Closures are implicitly created. We can't directly access it.

--------------------------------------------------------
Data Structures
Arrays:
Array is a DS that stores a list of values following the index format. They can be accessed using their index. Arrays are objects as well with their own properties. It can store any type of data. It is an iterable.
Add/delete elements:
->push(element)/pop(): End of array.
->unshift(element)/shift(): Start of array.
Note: push() & unshift() return new length of array likewise the other 2 return elemnt deleted.
->indexOf(element): Return index of existing element & -1 otherwise.
->includes()(ES6): Returns true for existing element & false otherwise.
->slice(start, end): Returns Sliced Array.
->splice(start, deleteCount): Returns Sliced Array but mutates the original array as well. Usually used to remove range of elements from our array.
->reverse(): Reverses the elements for the array. Returns a copy as well
->concat(array2): Concat 2 arrays and return resultant arr.
->forEach(function(currentEl, i, arr){}): Iterates the array, at each iteration calls the callback function passed as argument and passes current array element as an argument to this callback function. continue & break dont work here.
->map(callbackFunc(currentEl, index, array){}): Loops over the array, returns a brand new array with each position having a value resultant after applying passed callback function on corresponding elements of original array. Callback function recieves current element as argument per iteration & should return computed value for new array.
->filter(callback((currentEl, index, array){}): Filter out Array elements based on condition in callback function passsed as argument. Callback function should return a boolean. If it returns true, currentEl is added into output arr or else not.
->reduce(callback(accumulator, currentEl, i, array){}, accuInit): Condense the array into one single value and return it. Accucumulator is the value that is processed on each iteration of array element. The 2nd argument specifies initial value for our accumulator variable.
-> find(callback((currentEl, index, array){})(ES6): Returns first value for which callback function returns true. Just like filter except the fact that it only return 1st value satisfying condition.
-> findIndex(callback((currentEl, index, array){})(ES6): Returns index of first value for which callback function returns true. Just like filter except the fact that it only return 1st value satisfying condition.
-> some(callback((currentEl, index, array){}): Loops thru array elements & calls callback function that checks for a condition and returns a boolean. some returns true if any element returns true on condition from callback.
-> every(callback((currentEl, index, array){}): Same as some but returns true only if callback returns true on all elements.
-> flat(depth)(ES2019): Unpack nested array elements and return them all in one single continous array.
-> flatMap(callback())(ES2019): Same as Combining map() & flat().
-> sort(callbackFunction(current, next){}): Sorts original array elements. By default sorts based on type conversion to strings. Meaining it converts array elements to stringd & then sorts them alphabetically as if they were strings. It swaps current and next at any iteration if callback returns value greater than 0 and doesnt swap if it returns lesser than 0.
-> fill(value, start, end): Used to fill empty arrays that were created using new Array(size). Fills with the value and can take optional start and end index parameters. Can also fill in normal arrays where it replaces existing elements.
-> Array.from(iterator, callback(current, i){})(ES6): Create an array from iterator passed in and call callback on each element of iterator.

--------------

Sets(ES6):
Collection of unique values, no duplicates. It is an iterable. Creating a set is done by using new operator followed by Set(iterable) & needs an iterable when defining & ignores all duplicates from it. Elements are unordered in a set & thus don't have any index. It has the size property that specifies no. of elements in set(like length for arrays).
Add/delete elements:
-> add(element), delete()
-> has(element): Returns true for existing element & false otherwise.

--------------

Maps(ES6):
Maps are key->value pairs but unlike objects, the key can be of any datatype. Creating a map is done by using new operator followed by Map(). We can then add key-values to it using the set(key, value).
Add/delete elements:
->set(key, value): Returns the update map after adding passed arguments as key->values. Thus, it can be called in a chain to add multiple pairs.
->get(key): Value for corresponding key that was passed. Datatype matters.
->has(key): Same as sets.
->delete(key): Remove key->value.
We can populate the map when creating it as well. We need to pass an array of arrays that contains keys and respective values in them as argument to Map(). This is exactly how Object.entries(obj) returns an output therefore making it easy to convert an object to map. We can iterate maps just like arrays using for...of and they return key & values in an array per iteration. We can also use unpacking operator on it to basically revert it back to array structure from before.

-------------------------------------------------------------
DOM Manipulation
Refers to making JS interact with our HTML & CSS code(basically the webpage). 

DOM: Document Object Model
Structured representation of HTML elements. Updatable so that JS can be used to dynamically update webpage content/styles. DOM is automatically creater when browser page loads and stored in tree structure. Each HTML element is an object of the tree. document Object is the root of this tree & acts as an entry point to the tree. The tree not only includes elements but also content of the elements as child nodes. DOM isn't a part of JS. It belongs to WEB API implemented by all browsers. Alternatives are FETCH.

Methods I'm Learning:
->document.querySelector(element identifier): Selects an element out of the HTML page referencing the identifier used. Identifier could be element name, class/id name as well.
Note: Only selects 1st one if there exist more than 1 elements for identifier. To overcome this drawback, use querySelectorAll() instead.
->document.querySelector(element identifier).addEventListener(eventType, function): Creates an event listener on the selected DOM object. It listens for the event of type passed as argument and when event occurs, calls the function also passed as the argument. This calling of function happens implicitly by JS engine. The this keyword points to object on which eventListener is attached dynamically.
->document.getElementById(id): Selects an element with id passed as an argument. This method is only applicable for id & don't need the # symbol.
Note: Implicitly called function is also passed an event object as argument containing all properties of the event that has occured.
->element.insertAdjacentHTML(location, htmlString): Appends htmlString code at specified location of element in HTML file.
->event.preventDefault(): Prevent Form from submitting.
Note: HTML Input elements in a form by default generate a click event on the corresponding submit button when you hit enter when the input field is selected.

Properties I'm Learning:
->style: Modify CSS for the object. It's properties correspond to css styles but follow the camel case notation.
->textContent: The text that element actually displays.
->innerHTML: The entire element HTML including tags, classes, id and content as well.
->value: Current value in input field.
->classList: Returns collection of classes of the selected element. We use methods like add, remove, toggle on this property to update class selectors on the DOM object.

Note: Always store variables that determine state of the webpage(so called state vars) in JS code. Don't rely on storing it in the DOM itself.

Most effective way to make dynamic webpages is to create different CSS classes with respective styles and then dynamically update classList for elements. This helps aggregate multiple styles into single class which can then be easily updated using one line of JS.

Keyboard Input events are global and thus to handle them we addeventListener on document obj itself. The type of event is either keydown -> Key Pressed down, keyup -> Key press released, keypress -> Key kept pressed continously.

--------------

DOM is an interface between our JavaScript code & the HTML files that are rendered onto the browser. It is complex API that contains methods & properties to interact with the DOM Tree. DOM Tree nodes are objects of different types based on which the underlying methods & properties differ as well.
All nodes in the tree are objects of type Node. Node in turn has some child types:
-> Element: Element tag. It has a subtype called HTMLElement that has a subtype for every single HTML tag.
-> Text: Text inside any element.
-> Comment: Comments from HTML doc.
-> Document:
These objects follow Inheritance thus a child can access all the methods & properties from their ancestors.

-> document.documentElement selects entire html content.
-> element.getElementsByTagName('tag'): Returns a HTMLCollection with elements of the type specified. This HTMLCOllection is dynamically updated.

Creating DOM elements in JS:
-> document.createElement('tagname'): Creates a new DOM object which doesn't exist on webpage but only in JS.
-> element.before(element): Adds an element as sibling before. after() does the opposite.
-> element.append(element): Adds an element as child at end. prepend() does the opposite.
-> getComputedStyle(element): Returns Styles for the element from css files or from any sources.
-> element.getBoundingClientRect(): Returns DOMRect object that contains all data about the coordinates about the positioning of element.
-> window.pageXOffset: Scroll Offset from start of page. Same for YOffset as well.
-> document.documentElement.clientWidth/Height: Width & Height of current viewport.

--------------

Events:
EventTarget is the parent of Node & Window object types. It's an abstract type simple there for its children to inherit event listening functionalities.
Old way of handling events was by storing the callback function on the oneventtype property of element object. We can also remove event listeners when not needed using the removeEventListener() function. Events happen regardless of the matter that we listen for them and handle them or not.
Types of Events:
-> click: Clicked by cursor.
-> mouseenter: Cursor Hovers over the element. This doesn't bubble. opposite is mouseleave
-> mouseover: Cursor Hovers over the element. This bubbles. opposite is mouseout

Events aren't generated on the target element but instead on the root of the element. This is called as the capture phase of the event.This event now traverses down the DOM tree to target element node. Upon reaching the target elem, the target phase of the event begins. Here, it can be handled. After handling an event, the event traverses back up to the root through each of the target element's parent node in the so called bubbling phase. This is as if the event happened on all of it's parrent elements and each of it's parents can handle this same event as well during the bubbling phase. This traversal of events is called as Event Propagation. The target element on which the event happens always remains the same, but this event propagates to and from the target elem during the creation & bubbling phases. This is what allows us to handle this same event in its parents as well.
-> event.target: Stores target element. Doesn't change no matter which of the elements is handling the same event.
-> event.currentTarget: Stores the element currently handling this event. Changes to elem handling event during bubbling phase.
-> event.stopPropagation(): Stops Event Propagation from ever happening.
Note: addEventListener() by default handles event in the bubbling phase only. Thus, even if the even propagates from root to target during capture phase, it ignored even if one of the target's parent have handler for this event. To change this functionality so that events can be handled in capture phase as well, pass in true as 3rd argument to the function.

Event Delegation:
Handling the same event that may happen on one of several sibling elements in their parent element during bubbling phase is called as event delegation. They can be used to handle events on elems that are dyanamically inserted and that don't exist by default on the webpage.
1. Add Event Listener to Common Parent Element
2. Determine Element that generated the event.
3. Check if it's the target we want to handle or not.

--------------

DOM Traversing:
Traversing thru the DOM and selecting one element based on another elem. Used to select elements relative to some other elem. Or when the DOM Tree structure is dynamic & unknonwn.
Down:
->childnodes: Direct children nodes including comments etc.
->children: Direct children elements only.
Up:
->parentNode
->parentElement
->closest(): Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
Sideways:
->leftSibling

--------------

Intersection Observer API:
It is used to track intersections of one target element with some other element or the viewport itself when scrolling. It is way more efficient than listening for scroll events. To use this API, we create an IntersectionObserver() object with the new keyword. We also pass in a callback function and options object into IntersectionObserver(). We then call the observe() method on observer obj created and pass in the target element which we want to observe the intersection for. The options object specifies the element with which we want the intersection of our target to be observed(null for viewport) in the root property. We also pass the threshold at which we want the callback function to be called. The threshold specifies the percentage of target element at which we want the callback to happen. Whenever target element passes the threshold percentage specified, 

-----------------------------------------------------------
JS Theory, Implementation Details
-> JS Runtime & JS Engine
JS engine is responsible for running our JS code. It consists of a call stack & a heap. Call stack stores all of the execution contexts used to execute the code. Heap is where all objects related to program are stored.

--------------

-> Compilation vs Interpretation vs JIT Compilation:
Compiled Languages compile the code into machine code(binary) and store it in an executable file. Interpretation is when code is convrerted to machine code line by line when execution is actually being done. JS used to be interpreted language, but not anymore. Now it's a Just-In-Time Compiled language. This concept refers to code being converted to machine code all at once but this is done just before execution of the code. Note that there's no executable file generated here.
-- Just-In-Time Compilation in JS:
JIT Compilation works by first parsing JS code. It checks for errors, groups meaningful blocks of code together and stores it in a DS called Abstract Syntax Tree. This AST eventually gets compiled into machine code when its time to execute the code. The machine code then immediately starts executing in the JS Engine's call stack. Initial compilation of machine code is generated as fast as possible to start execution right away. Then while execution continues, JS Engine uses optimization techniques to optimize & recompile the code while the actual execution is happening as well. This is done in background in some system defined threads inaccessible through code.

--------------

-> JS Runtime (In Browser):
JS Runtime is like a container/environement within which JS code lives and is executed. It consists of the JS engine, Web APIs like DOM, Fetch API, Timers, etc(these are functionalities provided to JS & don't belong to JS, it accesses these thru global window object) and a callback queue(callback functions ready to be executed). An event loop takes events from callback queue and inserts them into call stack of JS Engine to execute it.
-> JS Runtime (In Node.js):
Everything is same except that Web APIs don't exist since they were being provided by the browser. Instead there are C++ bindings and Thread pools.

--------------

-> Execution Context in Call Stacks:
Execution context is environment within which JS code executes. It stores metadata & necessary info for code to be executed. The Global execution context is generated for Top level code(code that doesn't belong to any function). Theres exactly one global execution context per JS project. Then respective functions get their own execution contexts so that they too can be executed. These singular execution contexts together form the call stack.
Any EC includes:
1. Variable environements: declarations, arguments object.
2. Scope Chain: Scope of variables outside function.
3. this keyword.

--------------

-> Scope & Scope Chain:
Define where variable can & can't be accessed from. JS implements lexical scoping. Lexical scoping means scope for variables is controlled by placement of functions & blocks in the code. Scope is space/env in which it was declared.
Types of Scope -
1. Global: Accessible anywhere
2. Function(Local): Only in respective function
3. Block(ES6): Only let & const defined varaibles.
Note: If a scope needs to use a variable & doesn't find it in current scope, it searches for it up the scope chain. This process is called Variable Lookup. Copies of variables aren't made, instead they are searched for in scope chain. This doesn't work the other way around meanining, the scope chain only works upwards, not down or even sideways.

--------------

-> Hoisting:
Makes variables accesssible before they were declared in the code. Code is scanned for variable declarations before being executed in the EC. A new property for each declaration found is created in variable environment object. var declarations get hoisted, but when accessed their value shows as undefined & not the actually defined value. let & const also get hoisted, but aren't accessible in their scope before being initialized. The area from start of its scope to the declaration is called as TDZ-Temporal Dead Zone in which the variable is known to be declared by JS Engine due to hoisting but isn't accessible and throws a ReferenceError. TDZ is ES6.

Hoisting was introduced in JS to use functions before declaring them in techniques such as mutual recursion. But now, it usually gets more in the way of efficient & bug-free code. Thus, using let & const is a workaround the harm caused by Hoisting.

--------------

-> this Keyword:
Special variable created for every EC(Implying its created for every function that gets called). this is dynamically assigned a value. Assigned value depends on how the function gets called & is assigned the value only once function has been called.
1. Method of an object: this points to object calling function.
2. Normal Function: undefined(strict mode)/window object.
3. Arrow Functions: this doesn't get assigned.
4. Event Listener: DOM element of the handler.

--------------

-> Primitive Types vs Object(Reference) Types:
Primitive type variables reside in EC of the call stack whereas objects belong to heap. The primitive as well as reference variable identifiers point to a memory location in the callstack all the same, but the difference is that primitives store their value at this mem loc whereas reference types store a reference address to actual object mem loc from the heap in the mem loc from callstack.

-----------------------------------------------------------
Array Destructuring:
Destructuring - Unpacking complex DS like array, object into simple variables.
We enclose the list of variables into which we want to unpack in [] and then assign it the array. This will unpack the first n elements of the array into variables declared on LHS(here, n is no. of variables declared on LHS). Skip array elements as well by leaving blank between commas on LHS. Useful to swap to variables as well. It makes returning multiple values from a function easy as well. Return an array and then destructure while calling it. We can do nested destructuring for unpacking nested arrays.

We can similarly destructure objects. Replace [] by {} and specify exact property names from the object. The order or count doesn't matter. We can also rename these unpacked variables by specifying a new name after a colon. We can also add default values in case properties don't exist with the equal operator followed by the default value we want. If no default value is provided undefined is returned. It can be used for API calls & retrieve data from backend, etc. Also can be used in place of a long list of confusing parameters for a function. While calling function, pass parameters as an object with all arguments with a key-name. Then in function parameter list specify these key-names in any order in {} which destructures the passed object based on key-names into paramaters that can then be used in function.

--------------

Spread operator(...):
Used to spread out the values of an array. Similar to Destructuring but it doesn't store them in variables. Used for-
1. Shallow Copies: Copy array data into a new variable. This doesnt make just a new reference to older array but creates a new array with the same values.
2. Merge 2 arrays.
Note: It is usable on all iterables like-arrays, strings, maps, sets. Objects aren't iterables. But it can be used on Objects as well since ES2018.

It outputs multiple values separated by commas, implying it can be used while making arrays and passing arguments for function call.

--------------

Rest operator(...):
Same as Spread operator but used on LHS of = sign and does exactly opposite of spread operator. Can be used while destructuring to collect all values from the end that aren't assigned variables.

We can also use it to store any arbitrary number of arguments passed into a single array parameter using this array.

--------------

Nullish Coalescing Operator(??)(ES2020):
This operator treats only null & undefined as Falsy values. Implying '' and 0 aren't Falsy values. This helps using it in checking if a variable exists or not. Usually other methods work but they fail when the variable itself stores 0 or empty string and is clearly defined but the expression outputs False since these 2 values are considered Falsy. This is overcomed using the nullish coalescing operator.

--------------

Optional Chaining Operator(?.)(ES2020):
It is used to check whether nested objects actually exist before accessing any of it's further properties. Simply trying to access a non-existing property of an obj returns undefined, but if we wanted to access an object from inside object which may/may not exist, it leads to an error. In such a case, the optional chaining operator is used which acceses a property of nested object only if it actually exists.

-----------------------------------------------------------
Strings
Their individual letters can be accessed using 0 based index just like in arrays. It also has indexOf() & lastIndexOf() methods to get occurence position of passed letter/word in string.
Note: Strings are immutable thus any method called on a string returns a new substring and doesn't ever modify the actual string as it is a primitive datatype.

Technically, strings are a primitive datatype hence should'nt have any methods like reference datatypes. But JS converts any string to a string object with the same characters upon which the methods actually get called. This process is called boxing.
- Methods
1. toLowerCase()
2. toUpperCase()
3. trim(): Remove whitespaces from start & end of str
4. trimStart()ES2019
5. trimEnd()ES2019
6. replace(searchStr, replaceStr): Replace 1st occurence of passed argument with 2nd argument
7. replaceAll(searchStr, replaceStr)ES2021: Replaces all occurences.
8. includes(searchStr)
9. startsWith(searchStr)
10. endsWith(searchStr)
11. split(breakpoint): Splits str into array of strs at every occurence of specified breakpoint. 
12. join(concatStr): Concatenates an array of strs with passed str in-between each element. This is technically not a str method but an array method.
13. slice(startIndex): Returns string from index specified.
14. padStart()/padEnd(length, padding): Returns string with padding so that string matches specified length
15. repeat(repetitions)

-----------------------------------------------------------
Numbers
Numbers are always internally stored in decimals as floating point numbers. They are stored as 64 bit in base 2 format. JS has Buggy Behaviour due to engine being unable to correctly store fractions in base2 system.

Functions:
-> Number.parseInt(string): Extract number from string. String needs to start with the number.
-> Number.parseFloat(string): Same but for decimal nos.
-> Number,isFinite(value): Check if its a finite number.
-> Math.max(): Maximum value from range of values/iterator. It can also do type coercion if needed.
-> Math.random(): Randome Number every time between 0 & 1.
-> Math.trunc(): Remove decimal part of number.
-> Math.round(): Round up to closest integer.
-> Math.ceil(): Always Rounds up.
-> Math.floor(): Always rounds down. Works for negative nos as well.
-> num.toFixed(decimals): Returns string rounded to a fixed decimal points specified.

-----------------------------------------------------------
Date & Time
We can create dates using Date() class constructor with new keyword. Date objects have several methods to retrieve certain values for the date it stores. 
Methods:
-> obj.toISOString(): Returns in Internation standard for date representation.
-> obj.getTime(): Returns timestamp(Time elapsed since 1 Jan 1970) for date. 
-> Date.now(): Timestamp at current time.

Any Sort of operations done with dates like subtraction addition convert the dates to timestamps in miliseconds implicitly by JS engine as part of type coercion.

-----------------------------------------------------------
Object Oriented Programming
Object is a collection of properties(key:value pairs) and methods(functions as value). It allows us to give a name to each of the values being stored that can be used to access it unlike Arrays where we can access them using only their indices. Functions inside of an object are called as methods. Objects can be used to store similar type of data and manipulations on the data in a single place. Order of properties doesn't matter. 

Objects can also hold functions as properties since they are also a type of value in JS. These functions are called methods. Methods can also be accesssed in the same way.

Accessing Object Properties:
->Dot operator: Access property value by using the object_name.key syntax. This is followed by parameters in parantheses for methods.
->Brackets: Access property value by passing in an expression in [] brackets after object_name.
Note: Accessing non-existent property keys returns undefined. This is followed by parameters in parantheses for methods.

Objects in JS delegate their behaviour into prototypes which represent classes from traditional OOP. Thus any object linked to a prototype has access to & inherits all methods & properties that protoype contains. This is called as protypal inheritance. This is somewhat like how

Methods of creating Objects:
->Factory functions: These are simple functions that are passed arguments which are used to return an object with those arguments as it's values. They basically act like a factory that manufactures objects which have different values. If the key and parameter to function have same name, just the parameter name is sufficient to store that value in the object. The key for any functions can be neglected as well by directly defining the function.
->Constructor functions: These are functions that take arguments and use the 'this' keyword to define object members and methods. They are usually named in Pascal naming convention. 'this' is a reference to the object currently executing the specific code. When actually creating the new object 'new' keyword is used followed by the Constructor name with arguments passed to it. 'new' creates an empty JS object, sets the 'this' operator to point to this newly created object and returns an object from the constructor function implicitly. We use the prototype property of constructor function to define any methods we want all objects created using our constructor to inherit. Any constructor's protoype property is what is used as the protoype for any objects created using this cntr but its not the protype for itself.
Note: Such methods aren't a part of the objects this constructor creates, they are just accessible from protoype of constructor function. This can be checked using the __proto__ private property on objects instantiated using constructor.

The link between objects and their prototypes they inherited from their Constructor.protoype is called as prototype chain.

--------------

Classes(ES6):
Classes aren't technically a feature of JS but are simple syntactic sugar that make use of constructor functions and protoypes under the hood. They are created using a class keyword. This means classes are just a special type of functions in JS. It has a constructor() method. To initialise any new instance created. Whenever an object is instantiated using new kw, this constructor() is invoked that returns a new obj of the class type. Any methods defined in class definiton are stored in the class protoype which is inherited by any object instance of the class.

Classes aren't Hoisted. They're first-class citizens i.e. can be passed as arguments and returned from functions. Classes are always executed in strict mode.

--------------

Setters & Getters:
Instance methods used to get & set a property but look like simple properties. Define with set and get kws, then just use them on objects like properrties rather than invoking them or passing them any arguments. 